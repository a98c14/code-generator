using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace KeyGenerator
{
    public class KeyEngine
    {
        private readonly BaseConverter m_Converter;
        private readonly RNGCryptoServiceProvider m_Random = new(DateTime.Now.ToString() + DateTime.Now.ToString());
        private readonly StringBuilder m_StringBuilder = new();
        private readonly SHA256 m_SHA256 = SHA256.Create();
        
        private readonly int m_CodeLength;
        private readonly int m_SeedBitLength;

        private readonly byte[] m_PrivateKey;

        /// <summary>
        /// Stores the initial seed
        /// </summary>
        private readonly byte[] m_SeedBuffer;

        /// <summary>
        /// Stores the seed appended by salt (Private key)
        /// </summary>
        private readonly byte[] m_SaltBuffer;

        /// <summary>
        /// Stores the seed + checksum
        /// </summary>
        private readonly byte[] m_ResultBuffer;

        /// <summary>
        /// Creates an instance of the key engine. Used to create new keys and validate them
        /// </summary>
        /// <param name="privateKey">Private key to salt the seed with</param>
        /// <param name="digitSet">Character set to encode the code with</param>
        /// <param name="codeBitLength">Bit size length of code</param>
        public KeyEngine(string privateKey, string digitSet)
        {
            m_PrivateKey = Encoding.ASCII.GetBytes(privateKey); 
            m_Converter = new BaseConverter(digitSet);
            m_CodeLength = 40;
            m_SeedBitLength = 24;

            var keyLength = 40 / 8;
            var seedLength = 24 / 8;
            var checksumLength = keyLength - seedLength;

            m_SaltBuffer = new byte[m_PrivateKey.Length + seedLength];
            Array.Copy(m_PrivateKey, m_SaltBuffer, m_PrivateKey.Length);

            // Stores the seed 
            m_SeedBuffer = new byte[seedLength];

            // Stores the seed + checksum
            m_ResultBuffer = new byte[keyLength];
        }

        /// <summary>
        /// Generates cryptographically secure random numbers
        /// </summary>
        /// <param name="count">Number of keys to generate</param>
        /// <param name="seedSize">Key byte size</param>
        /// <returns>Randomly generated byte buffer</returns>
        public byte[] GenerateSeedsSecure(int count, int seedSize = 12)
        {
            var bufferLength = count * seedSize;
            var seeds = new byte[bufferLength];
            m_Random.GetBytes(seeds);
            return seeds;
        }

        /// <summary>
        /// Generates cryptographically secure random numbers
        /// </summary>
        /// <param name="count">Number of keys to generate</param>
        /// <param name="seedSize">Key byte size</param>
        /// <returns>Randomly generated byte buffer</returns>
        public byte[] GenerateSeeds(int count, int seedSize = 12)
        {
            var random = new Random();
            var bufferLength = count * seedSize;
            var seeds = new byte[bufferLength];

            random.NextBytes(seeds);
            return seeds;
        }

        public uint[] GenerateSeeds3Byte(int count)
        {
            var seeds = new uint[(int)Math.Pow(255, 3)];
            var index = 0;
            for (byte i = 0; i < 255; i++)
            {
                for (byte j = 0; j < 255; j++)
                {
                    for (byte k = 0; k < 255; k++)
                    {
                        var converter = new Int24Converter
                        {
                            Byte0 = k,
                            Byte1 = j,
                            Byte2 = i
                        };
                        seeds[index++] = converter.UIntValue;
                    }
                }
            }

            // There are probably faster ways but its ok
            var random = new Random();
            return seeds.OrderBy(x => random.Next(0, int.MaxValue)).Take(count).ToArray();
        }

        public List<string> GenerateKeys(int keyCount)
        {
            var codeLength = m_CodeLength / 8;
            var seedLength = m_SeedBitLength / 8;
            var checksumLength = codeLength - seedLength;

            var seeds = GenerateSeeds3Byte(keyCount);

            var keys = new List<string>();
            for (int i = 0; i < keyCount; i++)
            {
                var converter24 = new Int24Converter
                {
                    UIntValue = seeds[i],
                };

                m_SeedBuffer[0] = converter24.Byte0;
                m_SeedBuffer[1] = converter24.Byte1;
                m_SeedBuffer[2] = converter24.Byte2;

                // Add salt to current seed and compute hash
                Array.Copy(m_SeedBuffer, 0, m_SaltBuffer, m_PrivateKey.Length, seedLength);
                var hash = m_SHA256.ComputeHash(m_SaltBuffer);

                // Copy the seed to final buffer
                Array.Copy(m_SeedBuffer, 0, m_ResultBuffer, 0, seedLength);

                // Copy the checksum to final buffer
                Array.Copy(hash, 0, m_ResultBuffer, seedLength, checksumLength);

                var converter36 = new Int36Converter
                {
                    Byte0 = m_ResultBuffer[0],
                    Byte1 = m_ResultBuffer[1],
                    Byte2 = m_ResultBuffer[2],
                    Byte3 = m_ResultBuffer[3],
                    Byte4 = (byte)(m_ResultBuffer[4] & 0x0F), // Remove the last 4 bits because we have 36 bits not 40
                };
                var val = m_Converter.Convert(converter36.LongValue);
                keys.Add(DivideKeyWithChar(val, 4, '-'));
            }

            return keys;
        }

        public bool ValidateKey(string key, string divider = "-")
        {
            var codeLength = m_CodeLength / 8;
            var seedLength = m_SeedBitLength / 8;
            var checksumLength = codeLength - seedLength;

            var value = m_Converter.Convert(key.Replace(divider, ""));
            var converter36 = new Int36Converter
            {
                LongValue = value,
            };

            m_SeedBuffer[0] = converter36.Byte0;
            m_SeedBuffer[1] = converter36.Byte1;
            m_SeedBuffer[2] = converter36.Byte2;

            // Add salt to current seed and compute hash
            Array.Copy(m_SeedBuffer, 0, m_SaltBuffer, m_PrivateKey.Length, seedLength);
            var hash = m_SHA256.ComputeHash(m_SaltBuffer);

            // Add seed to result
            Array.Copy(m_SeedBuffer, 0, m_ResultBuffer, 0, seedLength);
            Array.Copy(hash, 0, m_ResultBuffer, seedLength, checksumLength);

            return converter36.Byte3 == m_ResultBuffer[3] &&
                converter36.Byte4 == (m_ResultBuffer[4] & 0x0F);
        }

        private string DivideKeyWithChar(string s, int freq, char divider) 
        {
            m_StringBuilder.Clear();
            for (var idx = 0; idx < s.Length; idx++)
            {
                if (idx % 4 == 0 && idx != 0)
                    m_StringBuilder.Append('-');
                m_StringBuilder.Append(s[idx]);
            }
            return m_StringBuilder.ToString();
        }
    }
}
